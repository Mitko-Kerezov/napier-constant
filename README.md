<p align="center" style="font-size: 120%">
<br><br><br><br><br><br>
  <b>Проект</b><br>
  по Разпределени Софтуерни Архитектури
  <br><br>
  <b>Пресмятане на Неперовото число</b>
  <br><br>
  Изготвил:<br>
  Димитър Керезов<br>
  <br><br>
  Ръководител:<br>
  ас. Христо Христов<br>

</p>
<br><br><br><br><br><br><br><br><br><br><br><br><br>
<p align="right">
    Проверил:......<br>
    (ас. Христо Христов)
</p>
<br><br><br><br><br><br><br><br>

## Условие
Да се пресметне Неперовото число със зададена точност, като се използва следният сходящ ред:

![Формула](https://raw.githubusercontent.com/Mitko-Kerezov/napier-constant/master/formula.png)

## Програмата

Програмата е реализирана чрез програмният език Python версия 2.6.6. Програмата може да се стартира посредством python изпълнимият файл:
```Shell
$ python napier.py -t 2 -p 1000
```

Параметрите, които програмата приема са:
* -h, --help - изкарва помощна информация за програмата
* -p P, --precision P - задава точност на изчисленията
* -t T, --tasks T - задава брой нишки за изпълнение
* -o File - указва име на файл, в който да бъде записано времето за изпълнение на програмата
* -q, --quiet - указва "тих" режим на програмата, при него нищо не се напечатва на стандартния изход

За генериране на тестови резултати, бе използвана BASH командата

```BASH
$ for ((precision=1000; precision<3001; precision+=1000)) {
    for ((count=1; count<=10; ++count)) {
        for ((threads=1; threads<=24; ++threads)) {
            python napier.py -t $threads -p $precision -o results/$precision/$threads.txt -q;
        };
    };
}
```

Чрез тази команда се пуска програмата да смята с точност съответно 1000, 2000 и 3000 по 10 пъти с от 1 до 24 нишки включително. Всички тези резултати бяха усреднени, за да се избегнат евентуални флуктуации при графичното изобразяване и изследване.

## Алгоритъм
Алгоритъмът за решаване разделя работата на нишките по равно, като използва деление по модул. Така например ако имаме да смятаме с точност 6 и две нишки, то първата нишка ще намери 0, 2 и 4-ти член, докато втората - 1, 3 и 5-ти член. Целта на този тип разделяне е максимално оползотворяване на работата на всички нишки.

## Проблеми, срещнати по време на разработка
Първоначалната имплементация на проекта бе писана на `NodeJS`, използвайки **cluster** модула. Разпалеляването се получаваше добре, но имах проблеми с пресмятането с голяма точност, поради естеството на езика **JavaScript**. Втората имплементация на проекта бе на `Python`, реализирана посредством **Thread** класът от модула `threading`. Поради естеството на езика `Python`, тази имплементация забавяше работата, вместо да я забърза. Това се дължи на `Global Interpreter Lock`, който е mutex в `Python`, забраняващ няколко нишки да изпълняват `Python` биткод едновременно. Третата имплементация на проекта бе на `C`, но при нея също имах проблем с прецизните сметки. Накрая се върнах към `Python` имплементацията, но вместо **Thread** класът, използвах `Process` класът от модула `multiprocessing`. Чрез стартирането на винаги нови процеси успях да избегна `Global Interpreter Lock` рестрикцията на езика. Кодът бе писан на `Windows 10` и тестван на `Python 3.5.1`. На `Linux` машината с хост `ats24.rmi.yaht.net` има инсталиран `Python 2.6.6`, което наложи известна промяна в кода, заради разликите между версия 2 и версия 3 на езика.

## Ускорение, ефективност и бързодействие
Тестовете бяха проведени на:
* 64-битов `Windows 10`, `Python 2.7.11`, процесор - 4-ядрен `Intel Core i7-4720HQ`
* 64-битов `Linux` с дистрибуция `CentOS` и `Python 2.6.6`, процесор - 12-ядрен `Intel Xeon X5650`

### Време за изпълнение и брой нишки
#### Windows
![Време за изпълнение](https://raw.githubusercontent.com/Mitko-Kerezov/napier-constant/master/results/plots/execution-time.png)

### Ускорение
![Ускорение](https://raw.githubusercontent.com/Mitko-Kerezov/napier-constant/master/results/plots/acceleration.png)

### Ефективност
![Ефективност](https://raw.githubusercontent.com/Mitko-Kerezov/napier-constant/master/results/plots/efficiency.png)
